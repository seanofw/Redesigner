//-------------------------------------------------------------------------------------------------
//
//  Redesigner
//
//  Copyright (c) 2012-3 by Sean Werkema
//  All rights reserved.
//
//  This software is released under the terms of the "New BSD License," as follows:
//
//  Redistribution and use in source and binary forms, with or without modification, are permitted
//  provided that the following conditions are met:
//
//   * Redistributions of source code must retain the above copyright notice, this list of
//     conditions and the following disclaimer.
//
//   * Redistributions in binary form must reproduce the above copyright notice, this list of
//     conditions and the following disclaimer in the documentation and/or other materials
//     provided with the distribution.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
//  AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
//  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
//  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
//  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//-------------------------------------------------------------------------------------------------

using System;
using System.Linq;
using System.Text;

namespace Redesigner.Library
{
    /// <summary>
    /// This class creates .designer files given fully-parsed and reflected markup.
    /// </summary>
    public class DesignerWriter
    {
        #region Static Data

        /// <summary>
        /// The text to include at the start of the .designer file.
        /// </summary>
        private const string DesignerStart = @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated. 
// </auto-generated>
//------------------------------------------------------------------------------

namespace {1}
{{


    public partial class {2}
    {{
";

        /// <summary>
        /// A single declaration of a control within the .designer file.
        /// </summary>
        private const string Declaration = @"
        /// <summary>
        /// {0} control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::{1} {0};
";

        /// <summary>
        /// The text to include at the end of the .designer file.
        /// </summary>
        private const string DesignerEnd = @"    }
}
";

        #endregion

        #region Methods

        /// <summary>
        /// Create a .designer file for the given parsed markup.
        /// </summary>
        /// <param name="compileContext">The context in which errors should be reported.</param>
        /// <param name="markupInfo">The fully-parsed markup.</param>
        /// <returns>The contents of the .designer file, as a string.</returns>
        public string CreateDesigner(ICompileContext compileContext, MarkupInfo markupInfo)
        {
            compileContext.Verbose("");
            compileContext.Verbose("Generating designer file for {0} with the {1} controls found in the markup.",
                markupInfo.ClassType.FullName, markupInfo.OutputControls.Count());

            // Get the actual runtime version from the System.Web assembly itself.
            string runtimeVersion = markupInfo.Assemblies[Common.SystemWebAssemblyName].ImageRuntimeVersion;
            if (runtimeVersion.StartsWith("v"))
            {
                runtimeVersion = runtimeVersion.Substring(1);
            }

            // Construct the initial part of the .designer.cs file.
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.AppendFormat(DesignerStart, runtimeVersion + ".0", markupInfo.ClassType.Namespace, markupInfo.ClassType.Name);

            // We must skip Content declarations, since those are not emitted as output.
            Type contentControl = typeof(System.Web.UI.WebControls.Content);

            // Spit out all of the controls.
            foreach (OutputControl outputControl in markupInfo.OutputControls)
            {
                string controlName = outputControl.Name;
                Type controlType = outputControl.ReflectedControl.ControlType;

                if (contentControl.IsAssignableFrom(controlType)) continue;

                if (string.IsNullOrEmpty(controlName))
                {
                    compileContext.Verbose("Skipping unnamed {0} control.", controlType.FullName);
                    continue;
                }

                compileContext.Verbose("Adding control declaration: {1} {0}.", controlName, controlType.FullName);

                stringBuilder.AppendFormat(Declaration, controlName, controlType.FullName);
            }

            stringBuilder.Append(DesignerEnd);

            compileContext.Verbose("End generation of designer file.");

            return stringBuilder.ToString();
        }

        #endregion
    }
}
